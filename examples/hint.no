hint fn mul(lhs: Field, rhs: Field) -> Field {
    return lhs * rhs;
}

hint fn add_mul_2(lhs: Field, rhs: Field) -> Field {
    let sum = lhs + rhs;
    return unsafe mul(sum, 2);
}

hint fn div(lhs: Field, rhs: Field) -> Field {
    return lhs / rhs;
}

hint fn ite(lhs: Field, rhs: Field) -> Field {
    return if lhs != rhs { lhs } else { rhs };
}

hint fn exp(const EXP: Field, val: Field) -> Field {
    let mut res = val;

    for num in 1..EXP {
        res = res + res ;
    }

    return res;
}

fn main(pub public_input: Field, private_input: Field) -> Field {
    assert_eq(public_input, 2);
    assert_eq(private_input, 2);

    let xx = unsafe add_mul_2(public_input, private_input); 
    let yy = unsafe mul(public_input, private_input);
    assert_eq(xx, yy * 2); // builtin call

    let zz = unsafe div(xx, public_input);
    assert_eq(zz, yy);

    let ww = unsafe ite(xx, yy);
    assert_eq(ww, xx);

    let kk = unsafe exp(4, public_input);
    log(kk);
    assert_eq(kk, 16);

    return xx;
}